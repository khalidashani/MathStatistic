---
title: "Monte Carlo Simulation"
author: "Khalid"
output: pdf_document
header-includes:
  - \usepackage{lscape}
  - \geometry{landscape}
geometry: margin=1in, landscape
---

# Monte Carlo Simulation

## Pseudorandom

```{r}
# Normal Distribution
rnorm(100, mean=10,sd=4)

# Binomial Distribution
rbinom(6,size=1,prob=0.5)

# Uniform Distribution
runif(50,min=0,max=100)
```

## MCS Example

```{r}
#Data Genaration
m <- 1000
n <- 100
x <- matrix(rnorm((m*n),896,174), nrow=m)
means <- apply(x,MARGIN=1,FUN=mean)
sdevs <- apply(x,MARGIN=1,FUN=sd)
medians <- apply(x,MARGIN=1,FUN=median)
ranges <- apply(apply(x,MARGIN=1,FUN=range),MARGIN=2,FUN=diff)

# Visualisation

## Hist Mean
hist(means,xlab="Means",ylab="Frequency", main="Monte Carlo
Means",cex.axis=1.5,cex.lab=1.6,cex.main=1.6)

## Hist Sdev
hist(sdevs,xlab="Std. Deviations",ylab= "Frequency",main="Monte Carlo
Std.Deviations",cex.axis=1.5,cex.lab=1.6,cex.main=1.6)

## Hist Median
hist(medians,xlab="Medians",ylab="Frequency", main="Monte Carlo
Medians",cex.axis=1.5,cex.lab=1.6,cex.main=1.6)

##  Hist Range
hist(ranges,xlab="Ranges",ylab="Frequency", main="Monte Carlo
Ranges",cex.axis=1.5,cex.lab=1.6,cex.main=1.6)
```

## Exercise

### Question 1

```{r}
# Monte Carlo Simulation to Estimate π
monte_carlo_pi <- function(n) {
  x <- runif(n, -1, 1) # produce x coordinate
  y <- runif(n, -1, 1) # produce y coordinate
  inside_circle <- (x^2 + y^2) <= 1  # Check if points fall inside the unit circle
  pi_estimate <- 4 * sum(inside_circle) / n  # Estimate π using the ratio
  return(pi_estimate)
}

# Parameters for the simulation
n_values <- as.integer(10^seq(1, 6, length.out = 100))  # Vary n from 10 to 1,000,000
pi_exact <- pi  # Exact value of π
estimates <- numeric(length(n_values))  # Store estimates of π
deviations <- numeric(length(n_values))  # Store deviations from exact value

# Perform Monte Carlo simulation for different n values
for (i in seq_along(n_values)) {
  n <- n_values[i]
  estimates[i] <- monte_carlo_pi(n)
  deviations[i] <- abs(pi_exact - estimates[i])
}

# Plotting
par(mfrow = c(1, 2))  # Create a 1x2 plot layout

# Plot π estimates
plot(n_values, estimates, type = "l", log = "x", col = "blue", 
     xlab = "Number of Samples (n)", ylab = "Estimated π", 
     main = "Monte Carlo Estimation of π")
abline(h = pi_exact, col = "red", lty = 2)  # Add horizontal line for exact π
legend("topright", legend = c("Estimated π", "Exact π"), 
       col = c("blue", "red"), lty = c(1, 2), bty = "n")

# Plot deviations
plot(n_values, deviations, type = "l", log = "xy", col = "green", 
     xlab = "Number of Samples (n)", ylab = "Deviation |π - π̂|", 
     main = "Deviation from Exact π")
legend("topright", legend = c("Deviation"), 
       col = c("green"), lty = c(1), bty = "n")
```

### Question 2

```{r}
set.seed(123)  # For reproducibility

# Parameters
n <- 30  # Sample size
mu <- 10  # True mean
sigma <- 2  # True standard deviation
N_sim <- 10000  # Number of simulations

# Initialize vectors to store the estimators
mean_estimates <- numeric(N_sim)
trimmed_mean_estimates <- numeric(N_sim)
median_estimates <- numeric(N_sim)

# Monte Carlo Simulation
for (i in 1:N_sim) {
  # Generate random sample
  sample <- rnorm(n, mean = mu, sd = sigma)
  
  # Compute estimators
  mean_estimates[i] <- mean(sample)  # Sample mean
  trimmed_mean_estimates[i] <- mean(sample, trim = 0.2)  # 20% trimmed mean
  median_estimates[i] <- median(sample)  # Sample median
}

# Compute biases
mean_bias <- mean(mean_estimates) - mu
trimmed_mean_bias <- mean(trimmed_mean_estimates) - mu
median_bias <- mean(median_estimates) - mu

# Display results
cat("Bias of Sample Mean: ", mean_bias, "\n")
cat("Bias of 20% Trimmed Mean: ", trimmed_mean_bias, "\n")
cat("Bias of Sample Median: ", median_bias, "\n")

# Visualization
boxplot(mean_estimates, trimmed_mean_estimates, median_estimates, 
        names = c("Mean", "Trimmed Mean", "Median"),
        main = "Distribution of Estimators",
        ylab = "Estimator Value",
        col = c("skyblue", "orange", "lightgreen"))
abline(h = mu, col = "red", lty = 2, lwd = 2)  # True mean
legend("topright", legend = "True Mean", col = "red", lty = 2, bty = "n")

```

### Question 3

#### Using Exponential Distribution

```{r}
set.seed(1000)  # For reproducibility

# Parameters
n <- 30  # Sample size
N_sim <- 10000  # Number of simulations

# Generate sample means from a non-normal distribution (Exponential)
sample_means <- numeric(N_sim)
for (i in 1:N_sim) {
  sample <- rexp(n, rate = 1)  # Exponential distribution with rate = 1
  sample_means[i] <- mean(sample)  # Compute sample mean
}

# Theoretical normal distribution
mean_theoretical <- 1  # Mean of Exponential(1) = 1
sd_theoretical <- 1 / sqrt(n)  # Standard deviation of the sampling distribution

# Visualization
hist(sample_means, breaks = 50, probability = TRUE, 
     main = "Distribution of Sample Means (CLT Demonstration)",
     xlab = "Sample Mean", col = "pink", border = "white")
curve(dnorm(x, mean = mean_theoretical, sd = sd_theoretical), 
      col = "red", lwd = 2, add = TRUE)  # Overlay normal curve
legend("topright", legend = c("Histogram", "Normal Curve"), 
       col = c("pink", "red"), lty = c(1, 1), lwd = c(10, 2), bty = "n")

```

#### Using Uniform Distribution

```{r}
set.seed(1000)  # For reproducibility

# Parameters
n <- 30  # Sample size
N_sim <- 10000  # Number of simulations

# Generate sample means from a uniform distribution
sample_means_uniform <- numeric(N_sim)
for (i in 1:N_sim) {
  sample <- runif(n, min = 0, max = 1)  # Uniform distribution between 0 and 1
  sample_means_uniform[i] <- mean(sample)  # Compute sample mean
}

# Theoretical normal distribution
mean_theoretical_uniform <- 0.5  # Mean of Uniform(0, 1) = (0 + 1) / 2
sd_theoretical_uniform <- sqrt((1/12) / n)  # Standard deviation of the sampling distribution

# Visualization
hist(sample_means_uniform, breaks = 50, probability = TRUE, 
     main = "Distribution of Sample Means (Uniform Distribution)",
     xlab = "Sample Mean", col = "lightblue", border = "white")
curve(dnorm(x, mean = mean_theoretical_uniform, sd = sd_theoretical_uniform), 
      col = "red", lwd = 2, add = TRUE)  # Overlay normal curve
legend("topright", legend = c("Histogram", "Normal Curve"), 
       col = c("lightblue", "red"), lty = c(1, 1), lwd = c(10, 2), bty = "n")
```

#### Using Gamma Distribution

```{r}
set.seed(1000)  # For reproducibility

# Parameters
n <- 30  # Sample size
N_sim <- 10000  # Number of simulations

# Generate sample means from a gamma distribution
sample_means_gamma <- numeric(N_sim)
for (i in 1:N_sim) {
  sample <- rgamma(n, shape = 2, rate = 1)  # Gamma distribution with shape = 2, rate = 1
  sample_means_gamma[i] <- mean(sample)  # Compute sample mean
}

# Theoretical normal distribution
mean_theoretical_gamma <- 2  # Mean of Gamma(2, 1) = shape / rate = 2
sd_theoretical_gamma <- sqrt(2 / n)  # Standard deviation of the sampling distribution

# Visualization
hist(sample_means_gamma, breaks = 50, probability = TRUE, 
     main = "Distribution of Sample Means (Gamma Distribution)",
     xlab = "Sample Mean", col = "lightgreen", border = "white")
curve(dnorm(x, mean = mean_theoretical_gamma, sd = sd_theoretical_gamma), 
      col = "red", lwd = 2, add = TRUE)  # Overlay normal curve
legend("topright", legend = c("Histogram", "Normal Curve"), 
       col = c("lightgreen", "red"), lty = c(1, 1), lwd = c(10, 2), bty = "n")
```

#### Using Beta Distribution

```{r}
set.seed(1000)  # For reproducibility

# Parameters
n <- 30  # Sample size
N_sim <- 10000  # Number of simulations

# Generate sample means from a beta distribution
sample_means_beta <- numeric(N_sim)
for (i in 1:N_sim) {
  sample <- rbeta(n, shape1 = 2, shape2 = 5)  # Beta distribution with shape1 = 2, shape2 = 5
  sample_means_beta[i] <- mean(sample)  # Compute sample mean
}

# Theoretical normal distribution
mean_theoretical_beta <- 2 / (2 + 5)  # Mean of Beta(2, 5) = shape1 / (shape1 + shape2)
sd_theoretical_beta <- sqrt((2 * 5) / ((2 + 5)^2 * (2 + 5 + 1))) / sqrt(n)  # Standard deviation of the sampling distribution

# Visualization
hist(sample_means_beta, breaks = 50, probability = TRUE, 
     main = "Distribution of Sample Means (Beta Distribution)",
     xlab = "Sample Mean", col = "lightcoral", border = "white")
curve(dnorm(x, mean = mean_theoretical_beta, sd = sd_theoretical_beta), 
      col = "red", lwd = 2, add = TRUE)  # Overlay normal curve
legend("topright", legend = c("Histogram", "Normal Curve"), 
       col = c("lightcoral", "red"), lty = c(1, 1), lwd = c(10, 2), bty = "n")
```

#### Using Poisson Distribution

```{r}
set.seed(1000)  # For reproducibility

# Parameters
n <- 30  # Sample size
N_sim <- 10000  # Number of simulations

# Generate sample means from a Poisson distribution
sample_means_poisson <- numeric(N_sim)
for (i in 1:N_sim) {
  sample <- rpois(n, lambda = 3)  # Poisson distribution with lambda = 3
  sample_means_poisson[i] <- mean(sample)  # Compute sample mean
}

# Theoretical normal distribution
mean_theoretical_poisson <- 3  # Mean of Poisson(lambda) = lambda
sd_theoretical_poisson <- sqrt(3 / n)  # Standard deviation of the sampling distribution

# Visualization
hist(sample_means_poisson, breaks = 50, probability = TRUE, 
     main = "Distribution of Sample Means (Poisson Distribution)",
     xlab = "Sample Mean", col = "blue", border = "white")
curve(dnorm(x, mean = mean_theoretical_poisson, sd = sd_theoretical_poisson), 
      col = "red", lwd = 2, add = TRUE)  # Overlay normal curve
legend("topright", legend = c("Histogram", "Normal Curve"), 
       col = c("blue", "red"), lty = c(1, 1), lwd = c(10, 2), bty = "n")
```
